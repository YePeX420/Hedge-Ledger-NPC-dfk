Great ‚Äî here‚Äôs an updated Prompt 3 tailored to the way your ETL is actually structured (modular sources, cluster-aware aggregation, METRIC_REGISTRY, and graceful skipping for unimplemented metrics).

You can paste this directly into the Replit backend project chat as the next step.


---

üîπ UPDATED PROMPT 3 ‚Äì Implement Phase 4 ETL (DeFi LP + Jeweler Staking)

> Context:

Phase 2 ETL implemented hero, behavior, and quest metrics.

Phase 3 ETL implemented Hunting (onchain_hunting) and PvP (onchain_pvp) metrics successfully.

The ETL is now modular, with a metric registry mapping metricSource:metricKey ‚Üí extractor functions, and cluster-aware queries.


Now we want to bring the DeFi Participation category fully online, which includes LP (liquidity provision) and Jeweler staking.




---

üéØ Overall Goal

Implement ETL extractors for:

onchain_lp

onchain_staking


and wire them to the following challenges from HEDGE_CHALLENGE_CONFIG:

LP (onchain_lp)

lp_depth ‚Üí lp_usd_value

lp_diversified ‚Üí pool_count

yield_harvester ‚Üí harvest_actions

diamond_hand_lp ‚Üí lp_duration_max_days


Jeweler staking (onchain_staking)

jeweler_stakeholder ‚Üí stake_usd_value

jeweler_loyalty ‚Üí stake_duration_days

jeweler_whale ‚Üí jewel_stake_amount (prestige toggle when ‚â• 10,000 JEWEL)



---

1. Implement onchain_lp ETL source

1.1 Create / update the module

Create or update:

src/etl/sources/onchain_lp.ts

Implement a SourceMetricFn called computeOnchainLpMetrics returning a MetricBag:

export const computeOnchainLpMetrics: SourceMetricFn = async ({ clusterId }) => {
  return {
    lp_usd_value: number,
    pool_count: number,
    harvest_actions: number,
    lp_duration_max_days: number,
  };
};

Expected logic:

lp_usd_value

Sum of current LP positions across all pools for the cluster, converted to USD.

If you already have a LP indexer or table (e.g. lp_positions), reuse it.

It‚Äôs fine if pricing is approximate (simple tokenPrice table).


pool_count

Count of distinct LP pools where this cluster has USD value above a small threshold (e.g., $1).

Helps avoid counting dust positions.


harvest_actions

Total number of LP reward harvest transactions.

Can be based on a lp_harvest_events table or similar.


lp_duration_max_days

For each pool, compute how many days the cluster has continuously held a non-zero position in that pool.

Return the maximum of these durations.

You can approximate with:

first LP deposit date per pool

last withdrawal date per pool

or use an existing ‚Äúdays_in_pool‚Äù field if you already track it.




1.2 Register source in METRIC_REGISTRY

Add an entry in the metric registry (e.g. METRIC_SOURCES) so that:

"onchain_lp" ‚Üí computeOnchainLpMetrics

1.3 Challenge mappings

Verify that computeChallengeMetricsForCluster uses the returned metricKeys as follows:

lp_depth ‚Üí metricSource: "onchain_lp", metricKey: "lp_usd_value"

lp_diversified ‚Üí "pool_count"

yield_harvester ‚Üí "harvest_actions"

diamond_hand_lp ‚Üí "lp_duration_max_days"



---

2. Implement onchain_staking ETL source

2.1 Create / update the module

Create or update:

src/etl/sources/onchain_staking.ts

Implement a SourceMetricFn called computeOnchainStakingMetrics returning:

export const computeOnchainStakingMetrics: SourceMetricFn = async ({ clusterId }) => {
  return {
    stake_usd_value: number,
    stake_duration_days: number,
    jewel_stake_amount: number,
  };
};

Expected logic:

stake_usd_value

Sum of the current value of all tokens staked at the Jeweler for this cluster, denominated in USD.

This can use staking position tables that track amounts by token and a token price table.


stake_duration_days

Longest continuous span (in days) during which the cluster maintained any stake at the Jeweler.

Similar to lp_duration_max_days, but for the Jeweler.


jewel_stake_amount

Total raw JEWEL amount staked at the Jeweler for this cluster.

Ignore CRYSTAL, JADE, AVAX, METIS here ‚Äî this is JEWEL-only, as we are using this for the jeweler_whale prestige challenge.



2.2 Register source in METRIC_REGISTRY

Add:

"onchain_staking" ‚Üí computeOnchainStakingMetrics

2.3 Challenge mappings

Ensure the aggregator wires:

jeweler_stakeholder ‚Üí metricSource: "onchain_staking", metricKey: "stake_usd_value"

jeweler_loyalty ‚Üí "stake_duration_days"

jeweler_whale ‚Üí "jewel_stake_amount"


For jeweler_whale, the challenge engine should treat this as a BOOLEAN prestige:

unlocked = true when jewel_stake_amount >= 10000 (threshold in config).

value can be stored as the raw amount; tier logic will take care of comparing to thresholdValue.



---

3. Testing & Verification

After implementing:

1. Run ETL for at least one test cluster with:

Known LP positions

Known staking values at the Jeweler



2. Query challenge_progress (or your equivalent progress table) for that cluster and inspect:

lp_depth, lp_diversified, yield_harvester, diamond_hand_lp

jeweler_stakeholder, jeweler_loyalty, jeweler_whale



3. Verify that:

Values are non-zero for the test cluster with activity.

jeweler_whale.unlocked moves to true if the JEWEL threshold is satisfied.

The admin dashboard shows up-to-date values under DeFi Participation.



4. Ensure the extractors still return zeros when there is no LP / staking data, and the metric registry skips any sources not yet implemented.




---

4. Constraints

Do not modify challengeConfig interfaces or change metricSource / metricKey strings.

Keep ETL modules idempotent and safe to call multiple times.

Keep existing ETL sources and behavior intact (just extend the registry + add new modules).

Do not change API response structure for /api/me/... or admin endpoints.



---

This prompt is ready to paste into your Replit backend chat as ‚ÄúPhase 4 ‚Äì DeFi ETL (LP + Jeweler)‚Äù.